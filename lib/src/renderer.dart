import 'dart:convert';
import 'dart:io';

import 'package:code_builder/code_builder.dart';
import 'package:dart_style/dart_style.dart';
import 'package:gql/ast.dart';
import 'package:gql/language.dart';
import 'package:path/path.dart' as p;

import 'config.dart';
import 'ir.dart';
import 'log.dart';
import 'plugin.dart';

/// Contract for rendering a document IR into generated outputs.
abstract class Renderer {
  Future<void> render(
      DocumentIr ir, Config config, List<GeneratorPlugin> plugins);
}

/// Default renderer that produces Dart files using code_builder.
class CodeRenderer implements Renderer {
  CodeRenderer(this.config);

  final Config config;
  late final String _schemaLibPath =
      p.normalize(p.join(p.dirname(config.schemaPath), 'schema.dart'));

  @override
  Future<void> render(
      DocumentIr ir, Config config, List<GeneratorPlugin> plugins) {
    return _emitDocument(ir, config, plugins);
  }

  Future<void> _emitDocument(
      DocumentIr ir, Config config, List<GeneratorPlugin> plugins) async {
    final outRoot = _outputRootFor(ir.path);
    final context = RenderContext(outputRoot: outRoot, config: config);
    final scalarBySymbol = _scalarSymbolMap(config);

    for (final plugin in plugins) {
      plugin.onDocument(ir, context);
    }
    final operationsDir = Directory(p.join(outRoot, 'operations'))
      ..createSync(recursive: true);
    final fragmentsDir = Directory(p.join(outRoot, 'fragments'))
      ..createSync(recursive: true);

    final recordNames = ir.records.map((r) => r.name).toSet();
    final enumNames = ir.enums.map((e) => e.name).toSet();
    final fragmentOwners = ir.fragments.map((f) => f.name).toSet();
    final fragmentRecords =
        ir.records.where((r) => fragmentOwners.contains(r.owner)).toList();
    final opRecords = <String, List<RecordIr>>{};
    for (final record in ir.records) {
      if (record.owner != null && !fragmentOwners.contains(record.owner)) {
        opRecords.putIfAbsent(record.owner!, () => []).add(record);
      }
    }
    final otherRecords = ir.records
        .where((r) =>
            r.owner == null ||
            (!fragmentOwners.contains(r.owner!) &&
                !opRecords.containsKey(r.owner!)))
        .toList();
    final fragmentRecordOwners = {
      for (final r in fragmentRecords) r.name: r.owner
    };
    final schemaBuilder = LibraryBuilder()
      ..directives
          .addAll(_scalarImportsForRecords(otherRecords, scalarBySymbol))
      ..body.add(Code('// Generated schema types\n'));
    for (final enm in ir.enums) {
      schemaBuilder.body.add(_emitEnum(enm));
    }
    for (final record in otherRecords) {
      schemaBuilder.body
          .addAll(_emitRecord(record, recordNames, enumNames, scalarBySymbol));
    }
    await _writeLibrary(_schemaLibPath, schemaBuilder.build());

    for (final op in ir.operations) {
      final opOwned = opRecords[op.name] ?? const [];
      final builder = LibraryBuilder()
        ..directives.addAll([
          if (config.compressQueries) Directive.import('../helpers.dart'),
          Directive.import(_relativeSchemaImport(
              p.join(operationsDir.path, '${op.name}.dart'))),
          ..._importsForRecords(opOwned, fragmentRecordOwners,
              prefix: '../fragments/'),
          ...op.fragments.map((f) => Directive.import('../fragments/$f.dart')),
          ..._scalarImportsForRecords(opOwned, scalarBySymbol),
        ])
        ..body.add(Code('\n// Generated by shazam\n'))
        ..body.add(Code(_operationConst(op.name, op.node)))
        ..body.add(
            Code('\n${_operationRequest(op.name, op.variableRecord?.name)}'))
        ..body.add(Code('\n${_operationParse(op)}'));
      for (final record in opOwned) {
        builder.body.addAll(
            _emitRecord(record, recordNames, enumNames, scalarBySymbol));
      }
      for (final plugin in plugins) {
        plugin.onLibrary(builder, ir, context);
      }
      await _writeLibrary(
          p.join(operationsDir.path, '${op.name}.dart'), builder.build());
    }

    for (final frag in ir.fragments) {
      final builder = LibraryBuilder()
        ..directives.addAll(
            _fragmentImports(frag, fragmentRecords, fragmentRecordOwners))
        ..directives.add(Directive.import(_relativeSchemaImport(
            p.join(fragmentsDir.path, '${frag.name}.dart'))))
        ..directives.addAll(_scalarImportsForRecords(
            fragmentRecords.where((r) => r.owner == frag.name).toList(),
            scalarBySymbol))
        ..body.add(Code('\n// Generated by shazam\n'))
        ..body.add(Code(_fragmentConst(frag.name, frag.node)));
      final owned = fragmentRecords.where((r) => r.owner == frag.name);
      for (final record in owned) {
        builder.body.addAll(
            _emitRecord(record, recordNames, enumNames, scalarBySymbol));
      }
      for (final plugin in plugins) {
        plugin.onLibrary(builder, ir, context);
      }
      await _writeLibrary(
          p.join(fragmentsDir.path, '${frag.name}.dart'), builder.build());
    }

    final helpersBuilder = LibraryBuilder()
      ..directives.addAll([
        Directive.import('dart:convert'),
        Directive.import('dart:io', show: ['gzip']),
        ...ir.operations
            .map((op) => Directive.import('operations/${op.name}.dart')),
      ])
      ..body.add(Code('\n// Generated helpers\n'))
      ..body.add(Code(
          'String decompress(String input) => utf8.decode(gzip.decode(base64Decode(input)));'))
      ..body.add(Code(_typeHelpers(ir)))
      ..body.add(Code(_serializerRegistry(ir)));
    await _writeLibrary(
        p.join(outRoot, 'helpers.dart'), helpersBuilder.build());

    final indexBuilder = LibraryBuilder();
    for (final op in ir.operations) {
      indexBuilder.body.add(Code("export 'operations/${op.name}.dart';"));
    }
    for (final frag in ir.fragments) {
      indexBuilder.body.add(Code("export 'fragments/${frag.name}.dart';"));
    }
    indexBuilder.body.add(Code("export 'helpers.dart';"));
    indexBuilder.body
        .add(Code("export '${p.relative(_schemaLibPath, from: outRoot)}';"));
    await _writeLibrary(p.join(outRoot, 'index.dart'), indexBuilder.build());
    for (final plugin in plugins) {
      plugin.onRenderComplete(ir, context);
    }
    logInfo('Wrote outputs to $outRoot');
  }

  List<Spec> _emitRecord(RecordIr record, Set<String> recordNames,
      Set<String> enumNames, Map<String, ScalarConfig> scalarTypes) {
    final fields = record.fields.values.toList()
      ..sort((a, b) => a.name.compareTo(b.name));

    final hasThunk = record.isInput && fields.any((f) => f.thunkTarget != null);
    if (hasThunk) {
      return _emitRecursiveInput(
          record, fields, recordNames, enumNames, scalarTypes);
    }

    final specs = <Spec>[];
    final typedefBuf = StringBuffer()..writeln('typedef ${record.name} = ({');
    for (final f in fields) {
      typedefBuf.writeln('  ${f.type} ${f.name},');
    }
    typedefBuf.writeln('});');
    specs.add(Code(typedefBuf.toString()));

    final deserialize = Method((b) {
      b
        ..name = 'deserialize${record.name}'
        ..returns = refer(record.name)
        ..requiredParameters.add(Parameter((p) => p
          ..name = 'json'
          ..type = refer('Map<String, dynamic>')));
      final bodyBuf = StringBuffer()..writeln('return (');
      for (final f in fields) {
        final expr = _deserializeForType(
            f.type, "json['${f.jsonKey}']", recordNames, enumNames, scalarTypes,
            thunkTarget: f.thunkTarget);
        bodyBuf.writeln('  ${f.name}: $expr,');
      }
      bodyBuf.writeln(');');
      b.body = Code(bodyBuf.toString());
    });
    specs.add(deserialize);

    if (record.isInput) {
      final serialize = Method((b) {
        b
          ..name = 'serialize${record.name}'
          ..returns = refer('Map<String, dynamic>')
          ..requiredParameters.add(Parameter((p) => p
            ..name = 'data'
            ..type = refer(record.name)));
        final bodyBuf = StringBuffer()..writeln('return {');
        for (final f in fields) {
          final expr = _serializeForType(
              f.type, 'data.${f.name}', recordNames, enumNames, scalarTypes,
              thunkTarget: f.thunkTarget);
          if (f.thunkTarget != null) {
            bodyBuf.writeln("  if (($expr) != null) '${f.jsonKey}': $expr,");
          } else {
            bodyBuf.writeln("  '${f.jsonKey}': $expr,");
          }
        }
        bodyBuf.writeln('};');
        b.body = Code(bodyBuf.toString());
      });
      specs.add(serialize);
    }

    if (record.variants.isNotEmpty) {
      specs.add(_emitMatcher(record, recordNames));
    }

    return specs;
  }

  String _operationConst(String name, OperationDefinitionNode node) {
    final source = printNode(node);
    final prefix = () {
      switch (node.type) {
        case OperationType.query:
          return 'query';
        case OperationType.mutation:
          return 'mutate';
        case OperationType.subscription:
          return 'subscribe';
      }
    }();
    final opName = '$prefix${_pascal(name)}';
    final withName = _injectOperationName(source, opName);
    if (config.compressQueries) {
      final compressed = base64Encode(gzip.encode(utf8.encode(withName)));
      final constName = '${config.namePrefix}${name}OperationCompressed';
      final getterName = '${config.namePrefix}${name}Operation';
      return "const $constName = '$compressed';\nString get $getterName => decompress($constName);";
    }
    return "const ${config.namePrefix}${name}Operation = r'''$withName''';";
  }

  String _operationRequest(String name, String? variableRecord) {
    final opConst = '${config.namePrefix}${name}Operation';
    final builderName = 'build${config.namePrefix}${name}Request';
    if (variableRecord == null) {
      return '''
Map<String, dynamic> $builderName({Map<String, dynamic>? variables}) {
  return {
    'query': $opConst,
    if (variables != null) 'variables': variables,
  };
}
''';
    }
    return '''
Map<String, dynamic> $builderName({$variableRecord? variables}) {
  return {
    'query': $opConst,
    if (variables != null) 'variables': serialize$variableRecord(variables),
  };
}
''';
  }

  String _operationParse(OperationIr op) {
    final parseName = 'parse${config.namePrefix}${op.name}Response';
    final recordType = op.record.name;
    return '''
$recordType $parseName(Map<String, dynamic> json) {
  return deserialize$recordType(json);
}
''';
  }

  String _fragmentConst(String name, FragmentDefinitionNode node) {
    final source = printNode(node);
    return "const ${config.namePrefix}${name}Fragment = r'''$source''';";
  }

  String _typeHelpers(DocumentIr ir) {
    final interfaceMap = _emitTypeMap(ir.interfaceImplementations);
    final unionMap = _emitTypeMap(ir.unionVariants);
    return '''
const _interfaceImpls = <String, Set<String>>{
$interfaceMap};

const _unionVariants = <String, Set<String>>{
$unionMap};

bool isTypeName(dynamic record, String expected) {
  final typeName = (record as dynamic).typeName;
  return typeName == expected;
}

/// Checks if a record matches a concrete type, interface, or union name.
bool isTypeOf(dynamic record, String target) {
  final typeName = (record as dynamic).typeName;
  if (typeName == target) return true;
  final impls = _interfaceImpls[target];
  if (impls != null && impls.contains(typeName)) return true;
  final variants = _unionVariants[target];
  if (variants != null && variants.contains(typeName)) return true;
  return false;
}
''';
  }

  String _serializerRegistry(DocumentIr ir) {
    final buffer = StringBuffer()
      ..writeln('typedef ResponseParser<T> = T Function(Map<String, dynamic>);')
      ..writeln(
          'final responseParsers = <String, dynamic Function(Map<String, dynamic>)>{');
    for (final op in ir.operations) {
      final key = '${config.namePrefix}${op.name}';
      final parseName = 'parse${config.namePrefix}${op.name}Response';
      buffer.writeln("  '$key': $parseName,");
    }
    buffer.writeln('};');
    buffer.writeln(
        'dynamic Function(Map<String, dynamic>)? resolveParser(String key) => responseParsers[key];');
    return buffer.toString();
  }

  String _injectOperationName(String source, String name) {
    final trimmed = source.trimLeft();
    if (trimmed.startsWith('query ') ||
        trimmed.startsWith('mutation ') ||
        trimmed.startsWith('subscription ')) {
      // Already named; leave as-is.
      return source;
    }
    final opType = trimmed.split(RegExp(r'\\s+')).first;
    final rest = trimmed.substring(opType.length).trimLeft();
    return '$opType $name $rest';
  }

  String _emitTypeMap(Map<String, Set<String>> map) {
    final buffer = StringBuffer();
    for (final entry in map.entries) {
      final values = entry.value.map((e) => "'$e'").join(', ');
      buffer.writeln("  '${entry.key}': {$values},");
    }
    return buffer.toString();
  }

  String _pascal(String value) {
    if (value.isEmpty) return value;
    return value
        .split(RegExp(r'[_\s]+'))
        .map((part) =>
            part.isEmpty ? '' : part[0].toUpperCase() + part.substring(1))
        .join();
  }

  String _deserializeForType(
      String type,
      String source,
      Set<String> recordNames,
      Set<String> enumNames,
      Map<String, ScalarConfig> scalarTypes,
      {String? thunkTarget}) {
    final nullable = type.endsWith('?');
    final core = nullable ? type.substring(0, type.length - 1) : type;

    if (_isThunk(type)) {
      final inner = thunkTarget ?? _unwrapThunk(type);
      final deser = _deserializeForType(
          inner, source, recordNames, enumNames, scalarTypes);
      return nullable
          ? '$source == null ? null : () => $deser'
          : '() => $deser';
    }

    if (core.startsWith('List<') && core.endsWith('>')) {
      final inner = core.substring(5, core.length - 1);
      final src = nullable ? '($source as List?)' : '($source as List)';
      final chain = nullable ? '?.' : '.';
      final innerExpr =
          _deserializeForType(inner, 'e', recordNames, enumNames, scalarTypes);
      return "$src$chain" "map((e) => $innerExpr).toList()";
    }

    if (recordNames.contains(core)) {
      final deser = 'deserialize$core($source as Map<String, dynamic>)';
      return nullable ? '$source == null ? null : $deser' : deser;
    }

    if (enumNames.contains(core)) {
      final cast = '$source as String';
      final deser = '$core.values.byName($cast)';
      return nullable ? '$source == null ? null : $deser' : deser;
    }

    final scalar = scalarTypes[core];
    if (scalar != null) {
      final deser = '${scalar.symbol}.deserialize($source as String)';
      return nullable ? '$source == null ? null : $deser' : deser;
    }

    return '$source as ${nullable ? '$core?' : core}';
  }

  String _serializeForType(String type, String source, Set<String> recordNames,
      Set<String> enumNames, Map<String, ScalarConfig> scalarTypes,
      {String? thunkTarget}) {
    final nullable = type.endsWith('?');
    final core = nullable ? type.substring(0, type.length - 1) : type;

    if (_isThunk(type)) {
      final inner = thunkTarget ?? _unwrapThunk(type);
      final invoked = nullable ? '$source?.call()' : '$source()';
      return _serializeForType(
          inner, invoked, recordNames, enumNames, scalarTypes);
    }

    if (core.startsWith('List<') && core.endsWith('>')) {
      final inner = core.substring(5, core.length - 1);
      final chain = nullable ? '?.' : '.';
      final innerExpr =
          _serializeForType(inner, 'e', recordNames, enumNames, scalarTypes);
      return "$source$chain" "map((e) => $innerExpr).toList()";
    }

    if (recordNames.contains(core)) {
      final nonNullSource =
          nullable ? '($source! as $core)' : '($source as $core)';
      final ser = 'serialize$core($nonNullSource)';
      return nullable ? '$source == null ? null : $ser' : ser;
    }

    if (enumNames.contains(core)) {
      return nullable ? '$source?.name' : '$source.name';
    }

    final scalar = scalarTypes[core];
    if (scalar != null) {
      final ser = nullable ? '$source?.serialize()' : '$source.serialize()';
      return ser;
    }

    return source;
  }

  String _outputRootFor(String sourcePath) {
    final dir = p.dirname(sourcePath);
    return p.join(dir, config.outputDir);
  }

  Spec _emitEnum(EnumIr enm) {
    return Enum((b) {
      b
        ..name = enm.name
        ..values.addAll(
            enm.values.map((v) => EnumValue((ev) => ev..name = _enumCase(v))));
    });
  }

  String _enumCase(String name) {
    // Keep uppercase GraphQL enums as valid Dart identifiers; fallback to camel.
    final cleaned = name.replaceAll(RegExp(r'[^a-zA-Z0-9_]'), '_');
    if (RegExp(r'^[A-Z0-9_]+$').hasMatch(cleaned)) {
      return cleaned;
    }
    final parts = cleaned.split(RegExp(r'[_\\s]+'));
    final camel = parts
        .where((p) => p.isNotEmpty)
        .map((p) => p[0].toUpperCase() + p.substring(1).toLowerCase())
        .join();
    return camel.isEmpty
        ? 'value'
        : camel[0].toLowerCase() + camel.substring(1);
  }

  List<Directive> _importsForRecords(
      List<RecordIr> records, Map<String, String?> fragmentRecordOwners,
      {String prefix = 'fragments/'}) {
    final owners = <String>{};

    String? resolveOwner(String type) {
      final core = _coreType(type);
      return fragmentRecordOwners[core];
    }

    for (final record in records) {
      for (final field in record.fields.values) {
        final owner = resolveOwner(field.type);
        if (owner != null) owners.add(owner);
      }
    }

    return owners.map((o) => Directive.import('$prefix$o.dart')).toList();
  }

  Spec _emitMatcher(RecordIr record, Set<String> recordNames) {
    final entries = <Map<String, String>>[];
    for (final field in record.fields.values) {
      final core = _coreType(field.type);
      if (recordNames.contains(core) && field.nullable) {
        entries.add({'variant': core, 'field': field.name, 'type': core});
      }
    }
    if (entries.isEmpty) return Code('');

    return Extension((b) {
      b
        ..name = '${record.name}Matcher'
        ..on = refer(record.name);

      b.methods.add(Method((m) {
        m
          ..name = 'when'
          ..types.add(refer('T'))
          ..returns = refer('T')
          ..requiredParameters.add(Parameter((p) => p
            ..name = 'orElse'
            ..type = refer('T Function()')))
          ..optionalParameters.addAll(entries.map((entry) {
            final fieldName = entry['field']!;
            final type = entry['type']!;
            return Parameter((p) => p
              ..name = fieldName
              ..named = true
              ..required = true
              ..type = refer('T Function($type)'));
          }));
        final body = StringBuffer();
        for (final entry in entries) {
          final fieldName = entry['field']!;
          body.writeln(
              'if (this.$fieldName != null) return $fieldName(this.$fieldName!);');
        }
        body.writeln('return orElse();');
        m.body = Code(body.toString());
      }));

      b.methods.add(Method((m) {
        m
          ..name = 'maybeWhen'
          ..types.add(refer('T'))
          ..returns = refer('T?')
          ..optionalParameters.addAll(entries.map((entry) {
            final fieldName = entry['field']!;
            final type = entry['type']!;
            return Parameter((p) => p
              ..name = fieldName
              ..named = true
              ..type = refer('T Function($type)?'));
          }))
          ..optionalParameters.add(Parameter((p) => p
            ..name = 'orElse'
            ..named = true
            ..type = refer('T Function()?')));
        final body = StringBuffer();
        for (final entry in entries) {
          final fieldName = entry['field']!;
          body.writeln(
              'if ($fieldName != null && this.$fieldName != null) { return $fieldName(this.$fieldName!); }');
        }
        body.writeln('return orElse?.call();');
        m.body = Code(body.toString());
      }));
    });
  }

  List<Spec> _emitRecursiveInput(
      RecordIr record,
      List<FieldIr> fields,
      Set<String> recordNames,
      Set<String> enumNames,
      Map<String, ScalarConfig> scalarTypes) {
    final specs = <Spec>[];

    final classBuf = StringBuffer()
      ..writeln('class ${record.name} {')
      ..writeln('  const ${record.name}({');
    for (final f in fields) {
      classBuf.writeln('    this.${f.name},');
    }
    classBuf.writeln('  });');
    for (final f in fields) {
      classBuf.writeln('  final ${f.type} ${f.name};');
    }
    classBuf.writeln('}');
    specs.add(Code(classBuf.toString()));

    final deserBuf = StringBuffer()
      ..writeln(
          '${record.name} deserialize${record.name}(Map<String, dynamic> json) {')
      ..writeln('  return ${record.name}(');
    for (final f in fields) {
      final expr = _deserializeForType(
          f.type, "json['${f.jsonKey}']", recordNames, enumNames, scalarTypes,
          thunkTarget: f.thunkTarget);
      deserBuf.writeln('    ${f.name}: $expr,');
    }
    deserBuf.writeln('  );');
    deserBuf.writeln('}');
    specs.add(Code(deserBuf.toString()));

    final serBuf = StringBuffer()
      ..writeln(
          'Map<String, dynamic> serialize${record.name}(${record.name} data) {')
      ..writeln('  final _result = <String, dynamic>{');
    for (final f in fields.where((f) => f.thunkTarget == null)) {
      final expr = _serializeForType(
          f.type, 'data.${f.name}', recordNames, enumNames, scalarTypes);
      serBuf.writeln("    '${f.jsonKey}': $expr,");
    }
    serBuf.writeln('  };');
    for (final f in fields.where((f) => f.thunkTarget != null)) {
      final temp = '_${f.name}Value';
      serBuf.writeln('  final $temp = data.${f.name}?.call();');
      serBuf.writeln('  if ($temp != null) {');
      final inner = _serializeForType(
          f.thunkTarget!, temp, recordNames, enumNames, scalarTypes);
      serBuf.writeln("    _result['${f.jsonKey}'] = $inner;");
      serBuf.writeln('  }');
    }
    serBuf.writeln('  return _result;');
    serBuf.writeln('}');
    specs.add(Code(serBuf.toString()));

    return specs;
  }

  Map<String, ScalarConfig> _scalarSymbolMap(Config config) {
    final result = <String, ScalarConfig>{};
    for (final entry in config.scalarMapping.entries) {
      result[entry.value.symbol] = entry.value;
    }
    return result;
  }

  List<Directive> _scalarImportsForRecords(
      List<RecordIr> records, Map<String, ScalarConfig> scalarTypes) {
    final imports = <String>{};
    for (final record in records) {
      for (final field in record.fields.values) {
        final scalar = scalarTypes[_coreType(field.type)];
        if (scalar != null && scalar.hasImport) {
          imports.add(scalar.import!);
        }
      }
    }
    return imports.map((path) => Directive.import(path)).toList();
  }

  String _relativeSchemaImport(String fromFile) =>
      p.relative(_schemaLibPath, from: p.dirname(fromFile));

  bool _isThunk(String type) =>
      type.endsWith(' Function()') || type.endsWith(' Function()?');

  String _unwrapThunk(String type) {
    if (type.endsWith(' Function()?')) {
      return '${type.substring(0, type.length - ' Function()?'.length)}?';
    }
    if (type.endsWith(' Function()')) {
      return type.substring(0, type.length - ' Function()'.length);
    }
    return type;
  }

  List<Directive> _fragmentImports(FragmentIr frag,
      List<RecordIr> fragmentRecords, Map<String, String?> fragmentOwners) {
    final owned = fragmentRecords.where((r) => r.owner == frag.name);
    final owners = <String>{};

    for (final record in owned) {
      for (final field in record.fields.values) {
        final owner = fragmentOwners[_coreType(field.type)];
        if (owner != null && owner != frag.name) {
          owners.add(owner);
        }
      }
    }

    return owners
        .map((name) => Directive.import('../fragments/$name.dart'))
        .toList();
  }

  String _coreType(String type) {
    var current = type;
    if (current.endsWith('?')) {
      current = current.substring(0, current.length - 1);
    }
    if (current.endsWith(' Function()')) {
      current = current.substring(0, current.length - ' Function()'.length);
    } else if (current.endsWith(' Function()?')) {
      current =
          current.substring(0, current.length - ' Function()?'.length) + '?';
    }
    while (current.startsWith('List<') && current.endsWith('>')) {
      current = current.substring(5, current.length - 1);
      if (current.endsWith('?')) {
        current = current.substring(0, current.length - 1);
      }
    }
    return current;
  }

  String _camel(String value) {
    final p = _pascal(value);
    return p.isEmpty ? p : p[0].toLowerCase() + p.substring(1);
  }

  Future<void> _writeLibrary(String path, Library library) async {
    final emitter = DartEmitter.scoped(useNullSafetySyntax: true);
    final source = library.accept(emitter).toString();
    String formatted;
    try {
      formatted = DartFormatter().format(source);
    } on FormatterException catch (e) {
      await File('$path.raw').writeAsString(source);
      logError('Formatting failed for $path: ${e.message}');
      rethrow;
    }
    await File(path).create(recursive: true);
    await File(path).writeAsString(formatted);
  }
}
