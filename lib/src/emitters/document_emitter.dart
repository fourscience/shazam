import 'package:code_builder/code_builder.dart';
import 'package:shazam/src/config.dart';
import 'package:shazam/src/emitters/enum_emitter.dart';
import 'package:shazam/src/emitters/operation_emitter.dart';
import 'package:shazam/src/emitters/record_emitter.dart';
import 'package:shazam/src/import_planner.dart';
import 'package:shazam/src/ir/ir.dart';

/// Emits libraries for a single GraphQL document: schema, operations, fragments.
class DocumentEmitter {
  DocumentEmitter(
    this.importPlanner,
    this.recordEmitter,
    this.enumEmitter,
    this.operationEmitter,
  );

  final ImportPlanner importPlanner;
  final RecordEmitter recordEmitter;
  final EnumEmitter enumEmitter;
  final OperationEmitter operationEmitter;

  LibraryBuilder schemaLibrary({
    required List<RecordIr> records,
    required Iterable<EnumIr> enums,
    required Map<String, ScalarConfig> scalarTypes,
    required Set<String> recordNames,
    required Set<String> enumNames,
  }) {
    return LibraryBuilder()
      ..directives.addAll(importPlanner.metaImportIfNeeded(
        records: records,
        enums: enums,
      ))
      ..directives
          .addAll(importPlanner.scalarImportsForRecords(records, scalarTypes))
      ..body.add(const Code('// Generated schema types\n'))
      ..body.addAll(enums.map(enumEmitter.emitEnum))
      ..body.addAll(records.expand(
          (record) => recordEmitter.emitRecord(record, recordNames, enumNames)));
  }

  LibraryBuilder operationLibrary({
    required OperationIr operation,
    required List<RecordIr> ownedRecords,
    required Set<String> recordNames,
    required Set<String> enumNames,
    required Map<String, String?> fragmentRecordOwners,
    required Map<String, ScalarConfig> scalarTypes,
    required String fromFile,
    required Map<String, String> fragmentImports,
    required String helpersImport,
    String fragmentsPrefix = '',
  }) {
    final builder = LibraryBuilder()
      ..directives.addAll(importPlanner.directivesForOperation(
        ownedRecords: ownedRecords,
        fragmentRecordOwners: fragmentRecordOwners,
        fragments: operation.fragments,
        fromFile: fromFile,
        scalarTypes: scalarTypes,
        fragmentImportPaths: fragmentImports,
        fragmentsPrefix: fragmentsPrefix,
        helpersImport: helpersImport,
      ))
      ..body.add(const Code('\n// Generated by shazam\n'))
      ..body.add(
          Code(operationEmitter.operationConst(operation.name, operation.node)))
      ..body.add(Code('\n${operationEmitter.operationRequest(operation.name, operation.variableRecord?.name, operation.variableDefaults)}'))
      ..body.add(Code('\n${operationEmitter.operationParse(operation)}'));

    for (final record in ownedRecords) {
      builder.body
          .addAll(recordEmitter.emitRecord(record, recordNames, enumNames));
    }
    return builder;
  }

  LibraryBuilder fragmentLibrary({
    required FragmentIr fragment,
    required List<RecordIr> fragmentRecords,
    required Set<String> recordNames,
    required Set<String> enumNames,
    required Map<String, String?> fragmentOwners,
    required Map<String, ScalarConfig> scalarTypes,
    required String fromFile,
  }) {
    final builder = LibraryBuilder()
      ..directives.addAll(importPlanner.directivesForFragment(
        fragment: fragment,
        fragmentRecords: fragmentRecords,
        fragmentOwners: fragmentOwners,
        fromFile: fromFile,
        scalarTypes: scalarTypes,
      ))
      ..body.add(const Code('\n// Generated by shazam\n'))
      ..body.add(Code(operationEmitter.fragmentConst(fragment.name, fragment.node)));

    for (final record in fragmentRecords.where((r) => r.owner == fragment.name)) {
      builder.body
          .addAll(recordEmitter.emitRecord(record, recordNames, enumNames));
    }
    return builder;
  }
}
