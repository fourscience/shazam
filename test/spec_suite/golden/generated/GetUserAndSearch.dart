import '../schema.dart';
import 'fragments/GqlUserFull.dart';
import 'fragments/GqlUserPreview.dart';
import 'fragments/GqlPostPreview.dart';
import 'fragments/GqlCommentWithAuthor.dart';
import 'fragments/GqlPostFull.dart';

// Generated by shazam
const GqlGetUserAndSearchOperation =
    r'''query GetUserAndSearch($id: ID!, $term: String!, $withComments: Boolean! = true) {
  user(id: $id) {
    ...UserFull
  }
  search(term: $term) {
    __typename
    ... on User {
      ...UserPreview
    }
    ... on Post {
      ...PostPreview
    }
    ... on Comment {
      ...CommentWithAuthor
    }
  }
  posts(limit: 5) {
    ...PostFull
    comments @include(if: $withComments) {
      ...CommentWithAuthor
    }
  }
}''';
Map<String, dynamic> buildGqlGetUserAndSearchRequest({
  GqlGetUserAndSearchVariables? variables,
  String? operationName,
}) {
  final _vars = <String, dynamic>{"withComments": true};
  if (variables != null) {
    _vars.addAll(serializeGqlGetUserAndSearchVariables(variables));
  }
  return {
    'query': GqlGetUserAndSearchOperation,
    if (operationName != null) 'operationName': operationName,
    if (_vars.isNotEmpty) 'variables': _vars,
  };
}

GqlGetUserAndSearch parseGqlGetUserAndSearchResponse(
  Map<String, dynamic> json,
) => deserializeGqlGetUserAndSearch(json);
typedef GqlCommentCommentWithAuthor = ({
  GqlUserUserPreview author,
  String body,
  String id,
  String name,
  GqlCommentBodyId replies,
  GqlRole? role,
});
GqlCommentCommentWithAuthor deserializeGqlCommentCommentWithAuthor(
  Map<String, dynamic> json,
) {
  return (
    author: json['author'] as GqlUserUserPreview,
    body: json['body'] as String,
    id: json['id'] as String,
    name: json['name'] as String,
    replies: json['replies'] as GqlCommentBodyId,
    role: json['role'] == null
        ? null
        : GqlRole.values.byName(json['role'] as String),
  );
}

typedef GqlCommentListCommentWithAuthor = ({
  GqlUserUserPreview author,
  String body,
  String id,
  String name,
  GqlCommentBodyId replies,
  GqlRole? role,
});
GqlCommentListCommentWithAuthor deserializeGqlCommentListCommentWithAuthor(
  Map<String, dynamic> json,
) {
  return (
    author: json['author'] as GqlUserUserPreview,
    body: json['body'] as String,
    id: json['id'] as String,
    name: json['name'] as String,
    replies: json['replies'] as GqlCommentBodyId,
    role: json['role'] == null
        ? null
        : GqlRole.values.byName(json['role'] as String),
  );
}

typedef GqlGetUserAndSearch = ({
  GqlUserUserPreview author,
  String? bio,
  String body,
  GqlCommentCommentWithAuthor commentsBy,
  GqlPostPostPreview favoritePost,
  GqlUserUserPreview friends,
  String id,
  GqlUserUserPreview likedBy,
  GqlMetadataCreatedAtIsPublishedRating metadata,
  String name,
  GqlPostPostFullComments posts,
  GqlCommentBodyId replies,
  GqlRole? role,
  GqlSearchResultCommentPostUserTypename search,
  GqlStatsLikesReactionsViews stats,
  List<String> tags,
  String title,
  GqlUserUserFull user,
});
GqlGetUserAndSearch deserializeGqlGetUserAndSearch(Map<String, dynamic> json) {
  return (
    author: json['author'] as GqlUserUserPreview,
    bio: json['bio'] as String?,
    body: json['body'] as String,
    commentsBy: deserializeGqlCommentCommentWithAuthor(
      (json['commentsBy'] ?? json['comments']) as Map<String, dynamic>,
    ),
    favoritePost: deserializeGqlPostPostPreview(
      json['favoritePost'] as Map<String, dynamic>,
    ),
    friends: json['friends'] as GqlUserUserPreview,
    id: json['id'] as String,
    likedBy: json['likedBy'] as GqlUserUserPreview,
    metadata: json['metadata'] as GqlMetadataCreatedAtIsPublishedRating,
    name: json['name'] as String,
    posts: deserializeGqlPostPostFullComments(
      json['posts'] as Map<String, dynamic>,
    ),
    replies: json['replies'] as GqlCommentBodyId,
    role: json['role'] == null
        ? null
        : GqlRole.values.byName(json['role'] as String),
    search: deserializeGqlSearchResultCommentPostUserTypename(
      json['search'] as Map<String, dynamic>,
    ),
    stats: json['stats'] as GqlStatsLikesReactionsViews,
    tags: (json['tags'] as List).map((e) => e as String).toList(),
    title: json['title'] as String,
    user: deserializeGqlUserUserFull(json['user'] as Map<String, dynamic>),
  );
}

extension GqlGetUserAndSearchMatcher on GqlGetUserAndSearch {
  T when<T>(
    T Function() orElse, {
    required T Function(GqlUserUserFull) user,
    required T Function(GqlPostPostPreview) favoritePost,
  }) {
    if (this.user != null) return user(this.user!);
    if (this.favoritePost != null) return favoritePost(this.favoritePost!);
    return orElse();
  }

  T? maybeWhen<T>({
    T Function(GqlUserUserFull)? user,
    T Function(GqlPostPostPreview)? favoritePost,
    T Function()? orElse,
  }) {
    if (user != null && this.user != null) {
      return user(this.user!);
    }
    if (favoritePost != null && this.favoritePost != null) {
      return favoritePost(this.favoritePost!);
    }
    return orElse?.call();
  }
}

typedef GqlGetUserAndSearchVariables = ({
  String id,
  String term,
  bool withComments,
});
GqlGetUserAndSearchVariables deserializeGqlGetUserAndSearchVariables(
  Map<String, dynamic> json,
) {
  return (
    id: json['id'] as String,
    term: json['term'] as String,
    withComments: json['withComments'] as bool,
  );
}

Map<String, dynamic> serializeGqlGetUserAndSearchVariables(
  GqlGetUserAndSearchVariables data,
) {
  return {'id': data.id, 'term': data.term, 'withComments': data.withComments};
}

typedef GqlPostListPostPreview = ({
  GqlUserUserPreview author,
  String id,
  String name,
  GqlRole? role,
  String title,
});
GqlPostListPostPreview deserializeGqlPostListPostPreview(
  Map<String, dynamic> json,
) {
  return (
    author: json['author'] as GqlUserUserPreview,
    id: json['id'] as String,
    name: json['name'] as String,
    role: json['role'] == null
        ? null
        : GqlRole.values.byName(json['role'] as String),
    title: json['title'] as String,
  );
}

typedef GqlPostPostFullComments = ({
  GqlUserUserPreview author,
  String body,
  GqlCommentCommentWithAuthor comments,
  GqlCommentCommentWithAuthor commentsBy,
  String id,
  GqlUserUserPreview likedBy,
  GqlMetadataCreatedAtIsPublishedRating metadata,
  String name,
  GqlCommentBodyId replies,
  GqlRole? role,
  GqlStatsLikesReactionsViews stats,
  List<String> tags,
  String title,
});
GqlPostPostFullComments deserializeGqlPostPostFullComments(
  Map<String, dynamic> json,
) {
  return (
    author: json['author'] as GqlUserUserPreview,
    body: json['body'] as String,
    comments: deserializeGqlCommentCommentWithAuthor(
      json['comments'] as Map<String, dynamic>,
    ),
    commentsBy: deserializeGqlCommentCommentWithAuthor(
      (json['commentsBy'] ?? json['comments']) as Map<String, dynamic>,
    ),
    id: json['id'] as String,
    likedBy: json['likedBy'] as GqlUserUserPreview,
    metadata: json['metadata'] as GqlMetadataCreatedAtIsPublishedRating,
    name: json['name'] as String,
    replies: json['replies'] as GqlCommentBodyId,
    role: json['role'] == null
        ? null
        : GqlRole.values.byName(json['role'] as String),
    stats: json['stats'] as GqlStatsLikesReactionsViews,
    tags: (json['tags'] as List).map((e) => e as String).toList(),
    title: json['title'] as String,
  );
}

typedef GqlSearchResultCommentPostUserTypename = ({
  GqlUserUserPreview author,
  String body,
  String id,
  String name,
  GqlCommentBodyId replies,
  GqlRole? role,
  String title,
  String typeName,
});
GqlSearchResultCommentPostUserTypename
deserializeGqlSearchResultCommentPostUserTypename(Map<String, dynamic> json) {
  return (
    author: json['author'] as GqlUserUserPreview,
    body: json['body'] as String,
    id: json['id'] as String,
    name: json['name'] as String,
    replies: json['replies'] as GqlCommentBodyId,
    role: json['role'] == null
        ? null
        : GqlRole.values.byName(json['role'] as String),
    title: json['title'] as String,
    typeName: json['__typename'] as String,
  );
}

///  User is someone
typedef GqlUserListUserPreview = ({String id, String name, GqlRole? role});
GqlUserListUserPreview deserializeGqlUserListUserPreview(
  Map<String, dynamic> json,
) {
  return (
    id: json['id'] as String,
    name: json['name'] as String,
    role: json['role'] == null
        ? null
        : GqlRole.values.byName(json['role'] as String),
  );
}

///  User is someone
typedef GqlUserUserFull = ({
  GqlUserUserPreview author,
  String? bio,
  GqlPostPostPreview favoritePost,
  GqlUserUserPreview friends,
  String id,
  String name,
  GqlPostPostPreview posts,
  GqlRole? role,
  String title,
});
GqlUserUserFull deserializeGqlUserUserFull(Map<String, dynamic> json) {
  return (
    author: json['author'] as GqlUserUserPreview,
    bio: json['bio'] as String?,
    favoritePost: deserializeGqlPostPostPreview(
      json['favoritePost'] as Map<String, dynamic>,
    ),
    friends: json['friends'] as GqlUserUserPreview,
    id: json['id'] as String,
    name: json['name'] as String,
    posts: deserializeGqlPostPostPreview(json['posts'] as Map<String, dynamic>),
    role: json['role'] == null
        ? null
        : GqlRole.values.byName(json['role'] as String),
    title: json['title'] as String,
  );
}

extension GqlUserUserFullMatcher on GqlUserUserFull {
  T when<T>(
    T Function() orElse, {
    required T Function(GqlPostPostPreview) favoritePost,
  }) {
    if (this.favoritePost != null) return favoritePost(this.favoritePost!);
    return orElse();
  }

  T? maybeWhen<T>({
    T Function(GqlPostPostPreview)? favoritePost,
    T Function()? orElse,
  }) {
    if (favoritePost != null && this.favoritePost != null) {
      return favoritePost(this.favoritePost!);
    }
    return orElse?.call();
  }
}
